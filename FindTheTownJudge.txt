//approach - 1 - with 2 vectors
//time complexity - O(m + n)
//space complexity - O(n)
// class Solution {
// public:
//     int findJudge(int n, vector<vector<int>>& trust) {
//         vector<int> inDegree(n + 1);
//         vector<int> outDegree(n + 1);

//         for(vector<int> &vec: trust) {
//             int u = vec[0];
//             int v = vec[1];

//             inDegree[v]++;
//             outDegree[u]++;
//         }

//         for(int i =  1; i <= n; i++) {
//             if(inDegree[i] == n - 1 && outDegree[i] == 0) {
//                 return i;
//             }
//         }

//         return -1;
//     }
// };



//approach - 2 - with 1 vector<int>
//time complexity - O(n)
//space complexity - O(n)
class Solution {
public:
    int findJudge(int n, vector<vector<int>>& trust) {
        vector<int> inOutDegree(n + 1, 0); //size if n + 1, because we are ignoring 0th index

        for(vector<int> &vec: trust) {
            int u = vec[0];
            int v = vec[1];

            inOutDegree[u] = -1;
            inOutDegree[v] += 1;
        }

        for(int i =  1; i <= n; i++) { //we are ignoring 0th index
            if(inOutDegree[i] == n - 1) {
                return i;
            }
        }

        return -1;
    }
};
